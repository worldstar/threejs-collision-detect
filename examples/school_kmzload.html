<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - KMZ</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<meta name="Access-Control-Allow-Headers" content="*">
		<meta name="Access-Control-Allow-Methods" content="*">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> -
			<a href="https://developers.google.com/kml/documentation/kmzarchives" target="_blank" rel="noopener">KMZ</a> loader
		</div>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.js"></script>
		<script src="js/libs/jszip.min.js"></script>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { KMZLoader } from './jsm/loaders/KMZLoader.js';

			import { TrackballControls } from './jsm/controls/TrackballControls.js';
			import { DragControls } from './jsm/controls/DragControls.js';

			var container, stats;
			var camera, controls, scene, renderer,rotationPoint,box;
			var objects = [];
			var collisions = [];
			var checkxarea =false,checkyarea =false;
			init();
			createFloor();
			init_dragControls();
			render();
			//animate();
			function animate(){
				requestAnimationFrame(animate);
				render();
			}
			function init() {
				let world = new CANNON.World()
				world.gravity.set(0, -10, 0);

				var grid = new THREE.GridHelper(1, 1);
				var grid2 = new THREE.GridHelper(1, 1);

				grid2.position.x = 1.5;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x999999 );
				var light = new THREE.AmbientLight( 0xffffff ); // soft white light
				scene.fog = new THREE.Fog( 0xccddff, 500, 2000 );

				scene.add( light );

				// Create a rotation point.
				rotationPoint = new THREE.Object3D();
				rotationPoint.position.set(0, 0, 0);
				scene.add(rotationPoint);

				// var light = new THREE.DirectionalLight( 0xffffff );
				// light.position.set( 0.5, 1.0, 0.5 ).normalize();

				// var light2 = new THREE.DirectionalLight( 0xffffff );
				// light2.position.set( 0, -10,0 ).normalize();

				objects.push(grid);
				objects.push(grid2);

				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 500 );
  				// box.add(camera);

				camera.position.y = 5;
				camera.position.z = 10;

				scene.add( camera );
				scene.add( grid );
				scene.add( grid2);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				var loader = new KMZLoader();
				// loader.load( './models/kmz/20050120182.kmz', function ( kmz ) {
				// 	kmz.scene.position.y = 0;
				// 	kmz.scene.position.x = -0.5;
				// 	kmz.scene.position.z = 0.5;

				// 	console.log(kmz.scene);
    			// 	kmz.scene.scale.x = 0.001;
    			// 	kmz.scene.scale.y = 0.001;
    			// 	kmz.scene.scale.z = 0.001;
				// 	grid.add( kmz.scene );
				// } );
				loader.load( './models/kmz/Box.kmz', function ( kmz ) {
					kmz.scene.position.y = 0.5;
					grid.add( kmz.scene );
					//box = kmz.scene;
					calculateCollisionPointsBody(kmz.scene);
				} );
				loader.load( './models/kmz/Box.kmz', function ( kmz ) {
					kmz.scene.position.y = 0.5;
					grid2.add( kmz.scene );
					calculateCollisionPoints(kmz.scene);
				} );

			}
			function init_dragControls(){
				var dragControls = new DragControls(objects, camera, renderer.domElement);
				let tempx,tempy;
				dragControls.addEventListener('dragstart', function(event) {
				tempx =event.object.position.x;
				tempy =event.object.position.y;
				controls.enabled = false;
				dragControls.enabled  = true;
				renderer.render( scene, camera );
				});

				dragControls.addEventListener('drag', function(event) {
				detectCollisions();
			    if(checkxarea == true || checkyarea == true){
				    event.object.position.x = tempx;
					event.object.position.y = tempy;
				    // dragControls.enabled  = false;
				calculateCollisionPointsBody(event.object);
			    }else{
				calculateCollisionPointsBody(event.object);
				renderer.render( scene, camera );
			    }
			    // console.log(dragControls);
				});

				dragControls.addEventListener('dragend', function(event) {
			    if(checkxarea == true || checkyarea == true){
				    event.object.position.x = tempx;
					event.object.position.y = tempy;
			    }
				// if(checkxarea == true)
				// 	event.object.position.x -=0.1;
				// if(checkyarea == true)
				// 	event.object.position.y -=0.1;
				controls.enabled = true;

				calculateCollisionPointsBody(event.object);
				renderer.render( scene, camera );
				});
				
				var controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render );
				controls.update();

				window.addEventListener( 'resize', onWindowResize, false );

			}		
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			function render() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.render( scene, camera );
				if (collisions.length > 0 ) {
					//console.log(collisions);
					detectCollisions();
				}
			}
			function initCannon() {
         		world = new CANNON.World();
         		world.gravity.set(0,0,0);
      		    world.broadphase = new CANNON.NaiveBroadphase();
      		    world.solver.iterations = 10;
      		    shape = new CANNON.Box(new CANNON.Vec3(1,1,1));
      		    mass = 1;
      		    body = new CANNON.Body({
      		      mass: 1
      		    });
      		    body.addShape(shape);
      		    body.angularVelocity.set(0,10,0);
      		    body.angularDamping = 0.5;
      		    world.addBody(body);
      		}
			function createFloor() {
			  var geometry = new THREE.PlaneBufferGeometry( 10, 10 );
			  var material = new THREE.MeshToonMaterial( {color: 0x336633} );
			  var plane = new THREE.Mesh( geometry, material );
			  plane.rotation.x = -1 * Math.PI/2;
			  plane.position.y = 0;
			  scene.add( plane );
			}
			/**
			 * Collision detection for every solid object.
			 */
			function detectCollisions() {
			  // Get the user's current collision area.
			  // var bounds = {
			  //   xMin: rotationPoint.position.x - box.geometry.parameters.width / 2,
			  //   xMax: rotationPoint.position.x + box.geometry.parameters.width / 2,
			  //   yMin: rotationPoint.position.y - box.geometry.parameters.height / 2,
			  //   yMax: rotationPoint.position.y + box.geometry.parameters.height / 2,
			  //   zMin: rotationPoint.position.z - box.geometry.parameters.width / 2,
			  //   zMax: rotationPoint.position.z + box.geometry.parameters.width / 2,
			  // };
			  var bounds = box;
			  //console.log(bounds);
			  // Run through each object and detect if there is a collision.
			  for ( var index = 0; index < collisions.length; index ++ ) {
			    if (collisions[index].type == 'collision' ) {
			      if ( ( bounds.xMin <= collisions[ index ].xMax && bounds.xMax >= collisions[ index ].xMin ) &&
			         ( bounds.yMin <= collisions[ index ].yMax && bounds.yMax >= collisions[ index ].yMin) &&
			         ( bounds.zMin <= collisions[ index ].zMax && bounds.zMax >= collisions[ index ].zMin) ) {
			        // We hit a solid object! Stop all movements.
			        //stopMovement();
			        // Move the object in the clear. Detect the best direction to move.
			        if ( bounds.xMin <= collisions[ index ].xMax && bounds.xMax >= collisions[ index ].xMin ) {
			          // Determine center then push out accordingly.
			          var objectCenterX = ((collisions[ index ].xMax - collisions[ index ].xMin) / 2) + collisions[ index ].xMin;
			          var playerCenterX = ((bounds.xMax - bounds.xMin) / 2) + bounds.xMin;
			          var objectCenterZ = ((collisions[ index ].zMax - collisions[ index ].zMin) / 2) + collisions[ index ].zMin;
			          var playerCenterZ = ((bounds.zMax - bounds.zMin) / 2) + bounds.zMin;
			          // Determine the X axis push.
			          if (objectCenterX > playerCenterX) {
			 		    checkxarea = true;
			            //rotationPoint.position.x -= 1;
			          } else {
			        	checkxarea = false;
			            //rotationPoint.position.x += 1;
			          }
			        }else{
			        	checkxarea = false;
			        }
			        if ( bounds.zMin <= collisions[ index ].zMax && bounds.zMax >= collisions[ index ].zMin ) {
			          // Determine the Z axis push.
			          if (objectCenterZ > playerCenterZ) {
			          	checkyarea = true;
			          	//rotationPoint.position.z -= 1;
			          } else {
			        	checkyarea = false;
			            //rotationPoint.position.z += 1;
			          }
			        }else{
			        	checkyarea = false;
			        }
			      }else{
			        checkxarea = false;
			        checkyarea = false;
			      }
			    }
			  }
			}
			function calculateCollisionPoints(mesh, scale, type = "collision") {
			  // Compute the bounding box after scale, translation, etc.
			  var bbox = new THREE.Box3().setFromObject(mesh);
			  var bounds = {
			    type: type,
			    xMin: bbox.min.x,
			    xMax: bbox.max.x,
			    yMin: bbox.min.y,
			    yMax: bbox.max.y,
			    zMin: bbox.min.z,
			    zMax: bbox.max.z
			  };
			  collisions.push(bounds);
			}
			function calculateCollisionPointsBody(mesh, scale, type = "collision") {
			  // Compute the bounding box after scale, translation, etc.
			  var bbox = new THREE.Box3().setFromObject(mesh);
			  var bounds = {
			    type: type,
			    xMin: bbox.min.x,
			    xMax: bbox.max.x,
			    yMin: bbox.min.y,
			    yMax: bbox.max.y,
			    zMin: bbox.min.z,
			    zMax: bbox.max.z
			  };
			  box = bounds;
			}
		</script>
	</body>
</html>
